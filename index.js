require('dotenv').config();
const { Client, LocalAuth } = require('whatsapp-web.js');
const puppeteer = require('puppeteer');
const qrcode = require('qrcode-terminal');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const winston = require('winston');

// Configura√ß√£o inicial
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser.json());

// Fun√ß√£o para iniciar o navegador - corrigida com async/await
async function startBrowser() {
  try {
    // Configura√ß√µes para funcionar no Render.com
    const browserOptions = {
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage'],
      headless: true
    };
    
    // Verifica se est√° em produ√ß√£o (Render) ou desenvolvimento
    if (process.env.NODE_ENV === 'production') {
      browserOptions.executablePath = '/usr/bin/google-chrome-stable';
    } else {
      // Caminho local para Windows
      browserOptions.executablePath = process.env.CHROME_PATH || 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe';
    }
    
const puppeteer = require('puppeteer');

async function iniciarBot() {
    try {
        const browser = await puppeteer.launch({
            executablePath: '/usr/bin/google-chrome-stable', // Define o caminho manualmente
            headless: true, // Executa em modo headless (sem interface gr√°fica)
            args: [
                '--no-sandbox', 
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage', 
                '--disable-accelerated-2d-canvas', 
                '--disable-gpu'
            ],
        });

        console.log("Navegador iniciado com sucesso!");

        const page = await browser.newPage();
        return browser; // Retorna o navegador para uso posterior

    } catch (error) {
        console.error('Erro ao iniciar o navegador:', error);
        throw error; // Lan√ßa o erro para tratamento externo, se necess√°rio
    }
}

// Chamando a fun√ß√£o
iniciarBot().catch(console.error);


// Vari√°veis globais
let totalSales = 0;
let abandonedCheckouts = 0;
let pendingPayments = 0;
let interactionCount = 0;
let qualifiedLeads = 0;
const abandonedLeads = {};
const conversationHistory = {};
const MAX_HISTORY_LENGTH = 10;
let checkoutLink = process.env.CHECKOUT_LINK || 'https://seu-link-de-checkout.com'; // Link de checkout padr√£o

// Conhecimento sobre produtos
const productKnowledge = {
    "c√©rebro em alta performance": {
        description: "Um e-book onde ajudar√° a melhorar a sua quest√£o neuronal do c√©rebro e melhor cada dia a mais para ter uma vida saud√°vel.",
        link: "https://renovacaocosmica.shop/23/crb-fnl"
    },
    "corpo e mente": {
        description: "Recupere o equil√≠brio f√≠sico e emocional com um m√©todo natural e eficaz.",
        link: "https://renovacaocosmica.shop/23/crpint-fnl"
    },
    "sa√∫de imersiva": {
        description: "O futuro em suas m√£os: cuide-se com dispositivos vest√≠veis e realidade aumentada. Experimente a revolu√ß√£o da sa√∫de.",
        link: "https://renovacaocosmica.shop/23/fnl-imersiva"
    },
    "sa√∫de do amanh√£": {
        description: "Tecnologia de sa√∫de inovadora para cuidar de voc√™. Cuide da sua sa√∫de com tecnologias avan√ßadas.",
        link: "https://renovacaocosmica.shop/23/fnl-saude"
    },
    "sono profundo, vida renovada": {
        description: "Recupere-se enquanto dorme com sono profundo. Pare de se preocupar com noites mal dormidas.",
        link: "https://renovacaocosmica.shop/23/sono-fnl"
    },
    "rosa xantina": {
        description: "Voc√™ merece ter uma pele radiante e saud√°vel todos os dias! Com uma f√≥rmula poderosa e inovadora, o Rosa Xantina √© o segredo para uma pele deslumbrante.",
        link: "https://ev.braip.com/ref?pv=pro9y44w‚Å°=afijp7y0qm"
    },
    "os alongamentos essenciais": {
        description: "Melhore sua flexibilidade e alivie as tens√µes com 15 minutos di√°rios! Alongamentos simples para fazer em casa e aliviar as tens√µes.",
        link: "https://renovacaocosmica.shop/23/alg-fnl"
    },
    "renavidiol cba": {
        description: "Descubra o poder do Canabinoid Active System‚Ñ¢. A tecnologia que restaura a beleza da sua pele logo nas primeiras aplica√ß√µes!",
        link: "https://ev.braip.com/ref?pv=pro173dg‚Å°=afimex7zn1"
    },
    "nervocure": {
        description: "Conquiste uma vida sem dores de forma 100% segura e comprovada. Aux√≠lio na diminui√ß√£o das dores, queima√ß√£o, formigamentos, agulhadas, choques e dorm√™ncia.",
        link: "https://renovacaocosmica.shop/23/nervocuretic"
    },
    "100queda": {
        description: "Trinoxidil Americano! O √∫nico tratamento do mundo capaz de restaurar at√© 2.000 fios de cabelo por semana!",
        link: "https://ev.braip.com/ref?pv=pro4rxm7‚Å°=afivpggv51"
    },
    "hemogotas": {
        description: "O √∫nico tratamento natural que age de dentro para fora com tecnologia americana avan√ßada. Al√≠vio r√°pido e duradouro para hemorr√≥idas.",
        link: "https://ev.braip.com/ref?pv=pror2eex‚Å°=afilxjyn16"
    }
};

// Configura√ß√£o da pasta de logs
const logsDir = path.join(__dirname, 'logs');
if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
}

// Configura√ß√£o de logs
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.Console({ format: winston.format.simple() }),
        new winston.transports.File({ filename: path.join(logsDir, 'error.log'), level: 'error' }),
        new winston.transports.File({ filename: path.join(logsDir, 'combined.log') }),
    ],
});

// Configura√ß√£o do cliente WhatsApp
const client = new Client({
    authStrategy: new LocalAuth(),
    puppeteer: {
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage'],
        executablePath: process.env.NODE_ENV === 'production' 
            ? '/usr/bin/google-chrome-stable' 
            : process.env.CHROME_PATH || undefined
    }
});

// Fun√ß√£o para enviar QR Code
client.on('qr', (qr) => {
    console.log('Escaneie o QR Code abaixo para conectar:');
    qrcode.generate(qr, { small: true });
});

// A√ß√£o quando o cliente WhatsApp estiver pronto
client.on('ready', () => {
    console.log('Bot conectado e pronto para uso!');
    logger.info('Bot conectado e pronto para uso.');
});

// Mapeamento de comandos
const commands = {
    '!limpeza': handleCleanupCommand,
    '!relatorio': handleReportCommand,
    '!group': handleGroupCommand,
    '!conhecimento': handleKnowledgeCommand,
    '!ajuda': handleHelpCommand,
    '!comandos': handleHelpCommand, // Alias para !ajuda
    '!sentimento': handleSentimentCommand,
    '!traduzir': handleTranslateCommand,
    '!ner': handleNerCommand,
    '!resumo': handleSummarizeCommand,
    '!gerar': handleGenerateTextCommand,
    '!imagem': handleImageRecognitionCommand,
    '!gerenciador': handleAdManagerCommand, // Novo comando para o Gerenciador de An√∫ncios
};

// Processamento de mensagens
client.on('message', async (message) => {
    try {
        const text = message.body.trim().toLowerCase();
        logger.info(`Mensagem recebida de ${message.from}: ${text}`);

        if (commands[text]) {
            await commands[text](message);
            return;
        }

        await processMessage(message);
    } catch (error) {
        logger.error('Erro ao processar mensagem:', error.message || error);
        await message.reply('Desculpe, ocorreu um erro ao processar sua mensagem.');
    }
});

// Fun√ß√µes auxiliares
async function waitForResponse(userId) {
    return new Promise((resolve) => {
        const listener = (msg) => {
            if (msg.from === userId && msg.body.trim() !== '') {
                client.off('message', listener);
                resolve(msg.body.trim());
            }
        };
        client.on('message', listener);
    });
}

function deleteFile(filePath) {
    try {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            logger.info(`Arquivo deletado: ${filePath}`);
        } else {
            logger.warn(`Arquivo n√£o encontrado: ${filePath}`);
        }
    } catch (error) {
        logger.error('Erro ao deletar arquivo:', error.message);
    }
}

// Fun√ß√£o para buscar m√©tricas do Gerenciador de An√∫ncios via Hugging Face
async function fetchAdManagerMetrics() {
    try {
        const response = await axios.get(process.env.FB_ADS_API_URL || 'https://api-inference.huggingface.co/models/facebook-ad-metrics', {
            headers: {
                'Authorization': `Bearer ${process.env.HUGGINGFACE_API_TOKEN}`
            }
        });
        
        return response.data;
    } catch (error) {
        logger.error('Erro ao buscar m√©tricas do Gerenciador de An√∫ncios:', error.message);
        throw new Error('N√£o foi poss√≠vel obter as m√©tricas do Gerenciador de An√∫ncios.');
    }
}

// Novo comando para o Gerenciador de An√∫ncios
async function handleAdManagerCommand(message) {
    try {
        await message.reply('üîÑ Buscando m√©tricas do Gerenciador de An√∫ncios do Facebook...');
        
        const metrics = await fetchAdManagerMetrics();
        
        // Formata a resposta com as m√©tricas
        let response = `üìä *M√âTRICAS DO GERENCIADOR DE AN√öNCIOS*\n\n`;
        
        if (metrics) {
            response += `üìà *Performance*\n`;
            response += `- Impress√µes: ${metrics.impressions || 'N/A'}\n`;
            response += `- Alcance: ${metrics.reach || 'N/A'}\n`;
            response += `- Cliques: ${metrics.clicks || 'N/A'}\n`;
            response += `- CTR: ${metrics.ctr || 'N/A'}%\n\n`;
            
            response += `üí∞ *Custos*\n`;
            response += `- Custo total: R$ ${metrics.cost || 'N/A'}\n`;
            response += `- CPC m√©dio: R$ ${metrics.cpc || 'N/A'}\n`;
            response += `- CPM: R$ ${metrics.cpm || 'N/A'}\n\n`;
            
            response += `üéØ *Convers√µes*\n`;
            response += `- Total de convers√µes: ${metrics.conversions || 'N/A'}\n`;
            response += `- Custo por convers√£o: R$ ${metrics.cost_per_conversion || 'N/A'}\n`;
            
            if (metrics.recommendations && metrics.recommendations.length > 0) {
                response += `\nüí° *Recomenda√ß√µes*\n`;
                metrics.recommendations.forEach((rec, index) => {
                    response += `${index + 1}. ${rec}\n`;
                });
            }
        } else {
            response += `‚ùå N√£o foi poss√≠vel obter as m√©tricas no momento. Tente novamente mais tarde.`;
        }
        
        await message.reply(response);
    } catch (error) {
        logger.error('Erro ao processar o comando !gerenciador:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao buscar as m√©tricas do Gerenciador de An√∫ncios. Tente novamente mais tarde.');
    }
}

// Fun√ß√µes de comando existentes
async function handleCleanupCommand(message) {
    try {
        const tempDir = './temp';
        const cleanedFiles = [];
        if (fs.existsSync(tempDir)) {
            const files = fs.readdirSync(tempDir);
            for (const file of files) {
                const filePath = `${tempDir}/${file}`;
                fs.unlinkSync(filePath);
                cleanedFiles.push(`Arquivo deletado: ${file}`);
            }
        }
        let response = `üßπ Relat√≥rio de Limpeza:\n`;
        response += `- Total de itens limpos: ${cleanedFiles.length}\n`;
        response += `- Itens limpos:\n${cleanedFiles.join('\n') || 'Nenhum item foi limpo.'}`;
        await message.reply(response);
    } catch (error) {
        logger.error('Erro ao processar o comando !limpeza:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao processar o comando de limpeza.');
    }
}

async function handleReportCommand(message) {
    try {
        await message.reply('Por favor, forne√ßa a data no formato DD/MM/YYYY (ex.: 01/10/2023).');
        const response = await waitForResponse(message.from);
        if (response.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        const dateRegex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
        if (!dateRegex.test(response)) {
            await message.reply('‚ùå Data inv√°lida. Por favor, forne√ßa uma data no formato correto: DD/MM/YYYY.');
            return;
        }
        const report = `üìä Relat√≥rio para ${response}:\n` +
            `- Total de Intera√ß√µes: ${interactionCount}\n` +
            `- Leads Qualificados: ${qualifiedLeads}\n` +
            `- Leads Abandonados: ${Object.keys(abandonedLeads).length}\n` +
            `- Total de Vendas: ${totalSales}`;
        await message.reply(report);
    } catch (error) {
        logger.error('Erro ao processar o comando !relatorio:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao gerar o relat√≥rio.');
    }
}

async function handleGroupCommand(message) {
    try {
        await message.reply('Por favor, forne√ßa o nome ou identificador do grupo que deseja consultar.');
        const groupName = await waitForResponse(message.from);
        if (groupName.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        const summary = `üì¢ Resumo do Grupo "${groupName}":\n` +
            `- Total de Membros: 50\n` +
            `- T√≥picos Recentes: Estrat√©gias de marketing, promo√ß√µes de final de ano.\n` +
            `- Destaque: Discuss√£o sobre aumento nas vendas ap√≥s campanha publicit√°ria.`;
        await message.reply(summary);
    } catch (error) {
        logger.error('Erro ao processar o comando !group:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao consultar o grupo.');
    }
}

async function handleKnowledgeCommand(message) {
    try {
        await message.reply('Por favor, envie os dados ou informa√ß√µes que deseja que eu armazene.');
        const data = await waitForResponse(message.from);
        if (data.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        logger.info(`Dados recebidos para armazenamento: ${data}`);
        await message.reply('‚úÖ Dados recebidos e armazenados com sucesso! Eles ser√£o utilizados para enriquecer nossas intera√ß√µes futuras.');
    } catch (error) {
        logger.error('Erro ao processar o comando !conhecimento:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao armazenar os dados.');
    }
}

async function handleHelpCommand(message) {
    try {
        const helpMessage = `üõ†Ô∏è Lista de Comandos Dispon√≠veis:\n` +
            `- !relatorio: Solicita um relat√≥rio detalhado para uma data espec√≠fica.\n` +
            `- !group: Fornece um resumo das atividades e dados de um grupo espec√≠fico.\n` +
            `- !conhecimento: Permite que voc√™ envie dados para que eu armazene e utilize futuramente.\n` +
            `- !ajuda: Oferece suporte e explica como usar meus recursos.\n` +
            `- !sentimento: Analisa o sentimento de uma mensagem.\n` +
            `- !traduzir: Traduz mensagens entre ingl√™s e portugu√™s.\n` +
            `- !ner: Extrai entidades nomeadas de uma mensagem.\n` +
            `- !resumo: Gera um resumo de um texto longo.\n` +
            `- !gerar: Gera texto usando IA avan√ßada.\n` +
            `- !imagem: Reconhece objetos em imagens.\n` +
            `- !limpeza: Limpa arquivos tempor√°rios e logs antigos.\n` +
            `- !gerenciador: Mostra m√©tricas do Gerenciador de An√∫ncios do Facebook.\n` +
            `\nDica: Eu tamb√©m posso interpretar perguntas informais e fornecer respostas adaptadas ao contexto!`;
        await message.reply(helpMessage);
    } catch (error) {
        logger.error('Erro ao processar o comando !ajuda:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao exibir a lista de comandos.');
    }
}

async function handleSentimentCommand(message) {
    try {
        await message.reply('Por favor, envie a mensagem que deseja analisar.');
        const text = await waitForResponse(message.from);
        if (text.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        // Simula√ß√£o de an√°lise de sentimento
        const sentiment = ['Positivo', 'Negativo', 'Neutro'][Math.floor(Math.random() * 3)];
        await message.reply(`üåü Sentimento detectado: ${sentiment}`);
    } catch (error) {
        logger.error('Erro ao processar o comando !sentimento:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao analisar o sentimento.');
    }
}

async function handleTranslateCommand(message) {
    try {
        await message.reply('Por favor, envie o texto que deseja traduzir.');
        const text = await waitForResponse(message.from);
        if (text.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        // Simula√ß√£o de tradu√ß√£o
        const translation = text.split('').reverse().join(''); // Inverte o texto como exemplo
        await message.reply(`üåê Tradu√ß√£o: ${translation}`);
    } catch (error) {
        logger.error('Erro ao processar o comando !traduzir:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao traduzir o texto.');
    }
}

async function handleNerCommand(message) {
    try {
        await message.reply('Por favor, envie a mensagem da qual deseja extrair entidades nomeadas.');
        const text = await waitForResponse(message.from);
        if (text.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        // Simula√ß√£o de extra√ß√£o de entidades nomeadas
        const entities = ['Jo√£o (Pessoa)', 'S√£o Paulo (Local)', '2023 (Data)'];
        let entityList = 'üìã Entidades Nomeadas Detectadas:\n';
        for (const entity of entities) {
            entityList += `- ${entity}\n`;
        }
        await message.reply(entityList);
    } catch (error) {
        logger.error('Erro ao processar o comando !ner:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao extrair entidades nomeadas.');
    }
}

async function handleSummarizeCommand(message) {
    try {
        await message.reply('Por favor, envie o texto que deseja resumir.');
        const text = await waitForResponse(message.from);
        if (text.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        // Simula√ß√£o de resumo
        const summary = text.substring(0, 50) + '...'; // Limita o texto aos primeiros 50 caracteres
        await message.reply(`üìù Resumo: ${summary}`);
    } catch (error) {
        logger.error('Erro ao processar o comando !resumo:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao gerar o resumo.');
    }
}

async function handleGenerateTextCommand(message) {
    try {
        await message.reply('Por favor, envie o prompt para gera√ß√£o de texto.');
        const prompt = await waitForResponse(message.from);
        if (prompt.toLowerCase() === 'cancelar') {
            await message.reply('‚ùå Comando cancelado.');
            return;
        }
        // Simula√ß√£o de gera√ß√£o de texto
        const generatedText = `üìù Texto Gerado: Baseado no prompt "${prompt}", aqui est√° uma resposta simulada.`;
        await message.reply(generatedText);
    } catch (error) {
        logger.error('Erro ao processar o comando !gerar:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao gerar o texto.');
    }
}

async function handleImageRecognitionCommand(message) {
    try {
        await message.reply('Por favor, envie a imagem que deseja analisar.');
        // Espera pela imagem
        // Simula√ß√£o de reconhecimento de imagem
        await message.reply('üñºÔ∏è Para an√°lise de imagem, envie a imagem e aguarde o processamento.');
    } catch (error) {
        logger.error('Erro ao processar o comando !imagem:', error.message);
        await message.reply('Desculpe, ocorreu um erro ao analisar a imagem.');
    }
}

async function processMessage(message) {
    try {
        const chat = await message.getChat();
        await chat.sendStateTyping();

        let response;
        if (message.hasMedia) {
            const media = await message.downloadMedia();
            if (media.mimetype.startsWith('audio')) {
                // Cria diret√≥rio de media se n√£o existir
                const mediaDir = path.join(__dirname, 'media');
                if (!fs.existsSync(mediaDir)) {
                    fs.mkdirSync(mediaDir, { recursive: true });
                }
                
                const audioPath = path.join(mediaDir, `${message.id.id}.mp3`);
                fs.writeFileSync(audioPath, Buffer.from(media.data, 'base64'));
                const transcript = await transcribeAudio(audioPath);
                deleteFile(audioPath);
                response = await processTextMessage(transcript, message.from);
            } else if (media.mimetype.startsWith('image')) {
                response = await processImage(media.data);
            } else {
                response = 'üì¶ Formato de m√≠dia n√£o suportado.';
            }
        } else if (message.body && message.body.trim() !== '') {
            response = await processTextMessage(message.body, message.from);
        } else {
            response = 'Ol√°! üòä Como posso te ajudar hoje?';
        }

        await message.reply(response);
    } catch (error) {
        logger.error('Erro ao processar mensagem:', error.message || error);
        await message.reply('Desculpe, ocorreu um erro ao processar sua mensagem.');
    }
}

// Fun√ß√µes para processamento de m√≠dia
async function transcribeAudio(audioPath) {
    // Esta √© uma fun√ß√£o simulada, voc√™ precisar√° implementar a integra√ß√£o real
    logger.info(`Transcrevendo √°udio: ${audioPath}`);
    return 'Transcri√ß√£o simulada do √°udio.';
}

async function processImage(imageData) {
    // Esta √© uma fun√ß√£o simulada, voc√™ precisar√° implementar a integra√ß√£o real
    logger.info('Processando imagem recebida');
    return 'üñºÔ∏è Imagem recebida e processada.';
}

async function processTextMessage(text, userId) {
    // Respostas personalizadas com base na entrada do usu√°rio
    const greetings = ['ol√°', 'oi', 'ola', 'hello', 'hi'];
    const farewells = ['tchau', 'adeus', 'at√© logo', 'bye', 'goodbye'];

    if (greetings.some(g => text.toLowerCase().includes(g))) {
        return `Ol√°! üòä Como posso te ajudar hoje?`;
    }

    if (farewells.some(f => text.toLowerCase().includes(f))) {
        return `At√© logo! üëã Volte sempre que precisar.`;
    }

    // Verifica se o usu√°rio est√° pedindo um produto ou link de checkout
    const productKeywords = Object.keys(productKnowledge);
    for (const keyword of productKeywords) {
        if (text.toLowerCase().includes(keyword)) {
            const product = productKnowledge[keyword];
            return `üì¶ *${keyword.toUpperCase()}*\n${product.description}\nüîó Link: ${product.link}`;
        }
    }

    // Tenta gerar uma resposta usando a API de IA (Se configurada no .env)
    if (process.env.OPENAI_API_KEY) {
        try {
            const response = await axios.post(
                'https://api.openai.com/v1/completions',
                {
                    model: 'text-davinci-003',
                    prompt: text,
                    max_tokens: 50,
                },
                {
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                }
            );

            const generatedText = response.data.choices[0]?.text || 'Desculpe, n√£o entendi sua solicita√ß√£o.';
            return generatedText.trim();
        } catch (error) {
            logger.error('Erro ao usar API de IA:', error.message);
            // Fallback para resposta padr√£o em caso de erro
        }
    }
    
    // Resposta padr√£o caso n√£o tenha API configurada ou ocorra erro
    return 'Obrigado por sua mensagem! Se estiver interessado em nossos produtos, digite o nome do produto ou use o comando !ajuda para ver os comandos dispon√≠veis.';
}

// Rota para verifica√ß√£o de sa√∫de do servidor (importante para o Render)
app.get('/health', (req, res) => {
    res.status(200).send('OK');
});

// Inicializa o servidor express
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Servidor Express rodando na porta ${PORT}`);
});

// Inicializa o cliente WhatsApp
client.initialize().catch(err => {
    logger.error('Erro ao inicializar o cliente WhatsApp:', err);
    console.error('Erro ao inicializar o cliente WhatsApp:', err);
});